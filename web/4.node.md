## 1.Node和REPL

**node并不是一门语言，它是一个工具或者环境**，**一个不是浏览器的浏览器**

#### 1.js的发展

![image-20210323112918160](4.node.assets/image-20210323112918160.png)

#### 2.浏览器内核及工作的过程

![image-20210323113210096](4.node.assets/image-20210323113210096.png)

![image-20210323114047492](4.node.assets/image-20210323114047492.png)

#### 3.javascript引擎

![image-20210323114215846](4.node.assets/image-20210323114215846.png)

#### 4.浏览器内核组成

​    **Browser = WebCore +JavaScriptCore**

![image-20210323114852882](4.node.assets/image-20210323114852882.png)

#### 5.V8引擎

![image-20210323120307974](4.node.assets/image-20210323120307974.png)

![image-20210323120849628](4.node.assets/image-20210323120849628.png)

#### 6.node的本质

![image-20210323121437569](4.node.assets/image-20210323121437569.png)

![image-20210323121736599](4.node.assets/image-20210323121736599.png)

![image-20210323122039922](4.node.assets/image-20210323122039922.png)

#### 7.node的版本管理工具

**nvm-Windows**

~~~javascript
nvm list  查看已经安装过的node版本
nvm list available 查看可用的版本
设置node 和npm 的淘宝镜像
nvm node_mirror https://npm.taobao.org/mirrors/node/ 
nvm npm_mirror https://npm.taobao.org/mirrors/npm/
nvm install latest  安装最新版本
nvm use 14.00  选择对应的版本
~~~

![image-20210323130134076](4.node.assets/image-20210323130134076.png)



#### 8.node的REPL

![image-20210323132224350](4.node.assets/image-20210323132224350.png)

#### 9.NODE做后台的优势和特点

 传统后台语言：JAVA/Python/PHP/C#(.NET)...
 =>单线程的： 一心一意
 =>基于V8引擎渲染：快
 =>异步无阻塞的I/O操作：I/O (INPUT/OUTPUT)  对文件的读写
 =>event-driven事件驱动：类似于发布订阅或者回调函数

![image-20210119102005945](4.node.assets/image-20210119102005945.png)

 * JS运行在客户端浏览器中=>“前端”
 * 浏览器给JS提供可很多全局的属性和方法，例如：window.xxx（setInterval、setTimeout、eval、alert、JSON...）
 * JS运行在服务器端的NODE中=>“后台”
 * NODE也给JS提供很多的内置属性和方法，例如：http、fs、url、path...等对象中都提供很多API供JS操作
 * ===
 * 前端（浏览器运行JS）是限制I/O操作的
 * input type='file' 这种算是I/O操作，但是需要用户手动选择（而且还仅仅是一个读取不是写入）
 * NODE中运行JS是不需要限制I/O操作的

## 2.node的全局对象

#### 1.node程序传递参数

![image-20210323133332963](4.node.assets/image-20210323133332963.png)

~~~js
console.log(process.argv)

PS D:\project\lianxi\node\process> node .\node参数传递.js name=qinaye age=23
[
  'D:\\Program Files\\nodejs\\node.exe',
  'D:\\project\\lianxi\\node\\process\\node参数传递.js',
  'name=qinaye',
  'age=23'
]
~~~

![image-20210323133513988](4.node.assets/image-20210323133513988.png)

![image-20210323133953459](4.node.assets/image-20210323133953459.png)

#### 2.常见的全局对象

![image-20210323134409617](4.node.assets/image-20210323134409617.png)

![image-20210323140916907](4.node.assets/image-20210323140916907.png)

![image-20210323140938942](4.node.assets/image-20210323140938942.png)

![image-20210323142617908](4.node.assets/image-20210323142617908.png)

#### 3.特殊的全局对象

![image-20210323134815474](4.node.assets/image-20210323134815474.png)

## 3.javascript模块化

#### 1.什么是模块化

![image-20210323143602414](4.node.assets/image-20210323143602414.png)

![image-20210323143806771](4.node.assets/image-20210323143806771.png)

![image-20210323145016790](4.node.assets/image-20210323145016790.png)

#### 2.CommonJS规范

 NODE本身是基于CommonJS模块规范设计的，所以模块是NODE的组成

![image-20210323145939534](4.node.assets/image-20210323145939534.png)

案例：

![image-20210325214044511](4.node.assets/image-20210325214044511.png)

![image-20210325213346198](4.node.assets/image-20210325213346198.png)

![image-20210325213442063](4.node.assets/image-20210325213442063.png)

![image-20210325214743556](4.node.assets/image-20210325214743556.png)

#### 3.exports的本质

![image-20210325221741851](4.node.assets/image-20210325221741851.png)

![image-20210325222616712](4.node.assets/image-20210325222616712.png)

#### 4.module.exports的本质

![image-20210325223829996](4.node.assets/image-20210325223829996.png)

 ```
   1.CommonJS规定，每一个JS都是一个单独的模块（模块是私有的：里面涉及的值和变量以及函数等都是私有的，和其它JS文件中的内容是不冲突的）
   2.CommonJS中可以允许模块中的方法互相的调用
     B模块中想要调取A模块中的方法
       =>A导出
       =>B导入
   [导出]
     CommonJS给每一个模块（每个JS）中都设置了内置的变量/属性/方法
       module：代表当前这个模块[object]
       module.exports：模块的这个“属性”是用来导出当前模块的属性和方法的 [object]
       exports：是内置的一个“变量”，也是用来导出当前模块属性方法的，虽然和module.exports不就是一个东西，但是对应的值是同一个(module.exports=exports 值都是对象)
   [导入]
     require：CommonJS提供的内置变量，用来导入模块的（其实导入的就是module.exports暴露出来的东西）；导入的值也是[object]类型的；
 ```

![image-20210119135443909](4.node.assets/image-20210119135443909.png)

![image-20210119135331769](4.node.assets/image-20210119135331769.png)

![image-20210119141308326](4.node.assets/image-20210119141308326.png)

    CommonJS特点：
     1. 所有代码都运行在模块作用域，不会污染全局作用域（每一个模块都是私有的，包括里面所有的东西也都是私有的，不会和其它模块产生干扰）
     
     2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。（为了保证性能，减少模块代码重复执行的次数）
     
     3. 模块加载的顺序，按照其在代码中出现的顺序。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。

**提升案例**：

  A/B/C三个模块
    A中有一个sum方法：实现任意数求和
    B中有一个avg方法：实现任意数求平均（先求和再求平均：B中用到A）
    C中调取B中的avg，实现 12,23,34,45,56,67,78,89 求平均数

![image-20210119142510334](4.node.assets/image-20210119142510334.png)

#### 5.require的规则和原理

![image-20210327124734419](4.node.assets/image-20210327124734419.png)

![image-20210327125702742](4.node.assets/image-20210327125702742.png)

![image-20210327131435669](4.node.assets/image-20210327131435669.png)

![image-20210327132543846](4.node.assets/image-20210327132543846.png)

#### 6.AMD规范

![image-20210327134836227](4.node.assets/image-20210327134836227.png)

![image-20210327135110956](4.node.assets/image-20210327135110956.png)

#### 7.CMD规范

![image-20210327135125001](4.node.assets/image-20210327135125001.png)

![image-20210327135253016](4.node.assets/image-20210327135253016.png)

#### 8.ES6里面的模块化

![image-20210327135833528](4.node.assets/image-20210327135833528.png)

![image-20210327145325057](4.node.assets/image-20210327145325057.png)

![image-20210327145409645](4.node.assets/image-20210327145409645.png)

![image-20210327145442477](4.node.assets/image-20210327145442477.png)

![image-20210327145459960](4.node.assets/image-20210327145459960.png)

![image-20210327145522606](4.node.assets/image-20210327145522606.png)

![image-20210327145614612](4.node.assets/image-20210327145614612.png)

案例：

![image-20210327150523613](4.node.assets/image-20210327150523613.png)

![image-20210327145659045](4.node.assets/image-20210327145659045.png)

![image-20210327145754135](4.node.assets/image-20210327145754135.png)

![image-20210327145819802](4.node.assets/image-20210327145819802.png)

#### 9.node里面对es module 的支持

![image-20210327154108353](4.node.assets/image-20210327154108353.png)

![image-20210327154807623](4.node.assets/image-20210327154807623.png)

## 4.NPM模块管理

![image-20210329221831491](4.node.assets/image-20210329221831491.png)

![image-20210329222240092](4.node.assets/image-20210329222240092.png)

![image-20210329222522172](4.node.assets/image-20210329222522172.png)

![image-20210329222613903](4.node.assets/image-20210329222613903.png)

### 1.npm配置文件常见的属性

![image-20210329223451817](4.node.assets/image-20210329223451817.png)

![image-20210329223523277](4.node.assets/image-20210329223523277.png)

![image-20210329224045571](4.node.assets/image-20210329224045571.png)

### 2.版本管理的问题

![image-20210329224844674](4.node.assets/image-20210329224844674.png)

![image-20210329224910439](4.node.assets/image-20210329224910439.png)

### 3.npm install 命令

![image-20210329230437025](4.node.assets/image-20210329230437025.png)

![image-20210329230501555](4.node.assets/image-20210329230501555.png)

![image-20210329230520373](4.node.assets/image-20210329230520373.png)

![image-20210329230536033](4.node.assets/image-20210329230536033.png)

![image-20210329230655946](4.node.assets/image-20210329230655946.png)

### 4.npm 其他命令

![image-20210329232000761](4.node.assets/image-20210329232000761.png)

### 5.其他的安装包管理工具

![image-20210329232334629](4.node.assets/image-20210329232334629.png)

![image-20210329233542172](4.node.assets/image-20210329233542172.png)

![image-20210329235152142](4.node.assets/image-20210329235152142.png)

![image-20210329235212336](4.node.assets/image-20210329235212336.png)

## 6.node中常见的内置模块

### 1.fs内置模块

![image-20210329002001173](4.node.assets/image-20210329002001173.png)

#### 1.FS内置模块常用方法

![image-20210329002030002](4.node.assets/image-20210329002030002.png)

##### 1.读取文件的状态信息 创建时间、 大小等

![image-20210329002403813](4.node.assets/image-20210329002403813.png)

![image-20210329003128174](4.node.assets/image-20210329003128174.png)

##### 2.文件描述符

![image-20210329005306739](4.node.assets/image-20210329005306739.png)

![image-20210329005248458](4.node.assets/image-20210329005248458.png)

##### 3.fs.mkdirSync  /  fs.mkdir 创建文件夹 

![image-20210121101751835](4.node.assets/image-20210121101751835.png)

**总结：无阻塞io操作==异步   ， 事件驱动==回调函数**

##### 4.fs.readdir / fs.readdirSync 读取文件夹

![image-20210329013926689](4.node.assets/image-20210329013926689.png)

![image-20210121102833980](4.node.assets/image-20210121102833980.png)

**读取文件下所有文件**：

~~~JS
function reddirflie(dirname){
  fs.readdir(dirname,{withFileTypes: true},(err,files)=>{  //withFileTypes返回文件类型
    files.forEach(item=>{
      if (item.isDirectory()) {
        const fliepath=path.resolve(dirname,item.name)
        reddirflie(fliepath) //递归方式
      } else {
        console.log(item.name);
      }
    })
  })
}

reddirflie("./")
~~~

![image-20210329014840764](4.node.assets/image-20210329014840764.png)

##### 6.fs.rmdir /fs.rmdirSync  删除文件夹

 但是当文件夹不为空的时候 删除不了 在Windows下会报错

![image-20210121103732781](4.node.assets/image-20210121103732781.png)

7.fs.writeFile() 向文件中写入内容** ，并且会覆盖文件中已经存在的内容，如果文件不存在会先创建文件

![image-20210329010014962](4.node.assets/image-20210329010014962.png)

![image-20210329010048342](4.node.assets/image-20210329010048342.png)

![image-20210329010109347](4.node.assets/image-20210329010109347.png)

![image-20210121110601139](4.node.assets/image-20210121110601139.png)

##### 8.fs.appendFile() //向文件中追加内容

![image-20210121110916386](4.node.assets/image-20210121110916386.png)

##### 9.fs.readFile() //读取文件中的内容

![image-20210121105900828](4.node.assets/image-20210121105900828.png)

##### **10.fs.copyFile() //拷贝文件到新的位置**

![image-20210121111626482](4.node.assets/image-20210121111626482.png)

##### **11.fs.unlink() //删除文件**

![image-20210121111128162](4.node.assets/image-20210121111128162.png)

#### 2.基于promise封装文件操作库

将fs里面常见的文件操作的方法进行封装成自己的模块，可以直接在其他地方使用，按照参数的个数和是否有返回值进行整合，

使用的时候只需要传入文件的路径 等

![image-20210121121246410](4.node.assets/image-20210121121246410.png)

![image-20210121123513196](4.node.assets/image-20210121123513196.png)

~~~js
let fs = require('fs'),
    path = require('path');
//=>存储的是当前模块执行所在的绝对路径(!==__dirname)
let dirname = path.resolve();

//=>MKDIR && RMDIR && READ-DIR && READ-FILE && COPY-FILE
['mkdir', 'rmdir', 'readdir', 'readFile', 'copyFile', 'unlink'].forEach(item => {
    exports[item] = function (pathname, copypath = '') {
        pathname = path.resolve(dirname, pathname);
        copypath = path.resolve(dirname, copypath);
        return new Promise((resolve, reject) => {
            let arg = [(err, result) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(result || '');
            }];
            item === 'readFile' ? arg.unshift('utf8') : null;
            item === 'copyFile' ? arg.unshift(copypath) : null;
            fs[item](pathname, ...arg);
        });
    };
});

//=>WRITE && APPEND
['writeFile', 'appendFile'].forEach(item => {
    exports[item] = function (pathname, content) {
        pathname = path.resolve(dirname, pathname);
        if (typeof content !== 'string') {
            //=>写入的内容我们规定必须是字符串才可以
            content = JSON.stringify(content);
        }
        return new Promise((resolve, reject) => {
            fs[item](pathname, content, 'utf8', (err, result) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(result || '');
            });
        });
    };
});

//=>READ-DIR
// exports.readFile = function (pathname) {
//     pathname = path.resolve(dirname, pathname);
//     return new Promise((resolve, reject) => {
//         fs.readFile(pathname, 'utf8', (err, result) => {
//             if (err) {
//                 reject(err);
//                 return;
//             }
//             resolve(result);
//         });
//     });
// };
~~~

#### 3.利用封装好的文件操作库合并压缩多个文件到一个文件

**合并并且压缩CSS**

~~~js
let {readFile, readdir, writeFile} = require('./utils/fsPromise');

//1.先把所有的CSS文件读取出来
readdir('less').then(result => {
    return result.filter(item => /\.CSS$/i.test(item));
}).then(result => {
    let arg = [];
    result.forEach(item => {
        arg.push(readFile(`less/${item}`));//=>分别调取READ-FILE方法，读取捕捉到的CSS文件，向数组中依次增加读取各个文件的PROMISE实例
    });
    //arg=[promise1,promise2...]  Promise.all：等待数组中所有的PROMISE实例都执行成功才算成功
    return Promise.all(arg);
}).then(result => {
    //=>RESULT:一个数组，存放所有文件读取的内容
    result = result.join('');
    return result.replace(/( |\n|\r)/g, '');
}).then(result => {
    return writeFile('less/build.min.css', result);
}).then(() => {
    console.log('创建成功');
});
~~~

**合并并且压缩less**

~~~js
//less.config.js
//=>需要把CONFIG放到当前项目的根目录中
let path = require('path'),
    rootPath=_dirname
    //rootPath = path.resolve();
module.exports = {
    //=>需要编译的LESS文件
    entry: [
        `${rootPath}/less/index.less`,
        `${rootPath}/less/detail.less`
    ],
    output: [
        `${rootPath}/css/index.min.css`,
        `${rootPath}/css/detail.min.css`
    ]
};
//index.js
let path = require('path'),
    lessc = require('less'),
    rootPath = path.resolve();

let {readFile, writeFile} = require(`./utils/fsPromise`),
    {entry, output} = require(`./less.config`);

module.exports = {
        //=>分别读取ENTRY中对应的LESS文件中的代码
        entry.forEach((item, index) => {
            readFile(item).then(result => {
                //=>把读取的LESS代码进行编译:编译为CSS
                lessc.render(result, {compress: true}, (err, result) => {
                    if (err) {
                        console.log(err);
                        return;
                    }
                    writeFile(output[index], result.css);
                });
            });
        });
};
~~~

#### 4.基于promise封装一个读文件的操作

~~~js
let fs = require('fs'),
    path = require('path');
let readFile = function (pathName) {
    //=>一般都会把传递的PATH-NAME进行处理：以当前项目的根目录为依托，我们只需要传递相对于根目录的相对目录地址，程序自动生成一个绝对目录地址
    /*
     * __dirname：当前模块所在的绝对路径（和模块中的方法在哪执行是没有关系的）
     * path.resolve()：当前模块中方法在哪个模块中执行的，那么对应的绝对路径是执行模块的绝对路径
     */
    pathName = path.resolve(path.resolve(), pathName);
    return new Promise((resolve, reject) => {
        fs.readFile(pathName, 'UTF-8', (err, result) => {
            if (err) {
                reject(err);
                return;
            }
            resolve(result);
        });
    });
};
module.exports = {
    readFile
};
~~~

### 2.path内置模块

![image-20210327160031661](4.node.assets/image-20210327160031661.png)

#### 1.path里面的基本方法

![image-20210328235613481](4.node.assets/image-20210328235613481.png)

![image-20210328233811539](4.node.assets/image-20210328233811539.png)

#### 2.path.join和path.resolve的区别

![image-20210328235746677](4.node.assets/image-20210328235746677.png)

![image-20210328235729437](4.node.assets/image-20210328235729437.png)

#### 3.path在webpack里面的应用

![image-20210328235952611](4.node.assets/image-20210328235952611.png)







### 3.url内置模块

**url.parse(url[,flag])**：

把一个URL地址进行解析，把地址中的每一部分按照对象键值对的方式存储起来

~~~JS
let url=require('url')
console.log(url.parse('http://www.baidu.com?user=qianye'));
//***
Url {
  protocol: 'http:',
  slashes: true,
  auth: null,
  host: 'www.baidu.com',
  port: null,
  hostname: 'www.baidu.com',
  hash: null,
  search: '?user=qianye',
  query: 'user=qianye',
  pathname: '/',
  path: '/?user=qianye',
  href: 'http://www.baidu.com/?user=qianye'
}
~~~

![image-20210125110807219](4.node.assets/image-20210125110807219.png)

~~~js
let url=require('url')
console.log(url.parse('http://www.baidu.com?user=qianye',true));
//=>第二个参数默认是FALSE，设置为TRUE可以把问号传参的部分也解析成为对象键值对的方式
~~~

![image-20210125111040149](4.node.assets/image-20210125111040149.png)

### 4.http内置模块

#### 1.创建web服务

![image-20210125114056186](4.node.assets/image-20210125114056186.png)

![image-20210403153307283](4.node.assets/image-20210403153307283.png)

~~~js
//=>创建WEB服务
let port = 8686;
http.createServer(() => {
    //=>当服务创建成功，并且客户端向当前服务器发送了请求，才会执行回调函数，并且发送一次请求，回调函数就会被触发执行一次
    console.log(`hello world!`);
}).listen(port, () => {
    //=>当服务创建成功,并且端口号也已经监听成功后,触发的回调函数
    console.log(`server is success，listen on ${port}！`);
});

 ```
  注意：基于NODE创建后台程序，我们一般都创建一个server模块，在模块中实现创建WEB服务，
  和对于请求的处理（并且我们一般都会把server模块放到当前项目的根目录下）
 /*
 * 客户端如何向创建的服务器发送请求
 *   对应好协议、域名、端口等信息，在浏览器中或者AJAX等中发送请求即可
 *
 *   http://localhost:8686/...  服务在电脑上，localhost本机域名，也就是本机的客户端浏览器，访问本机的服务器端程序
 *
 *   http://IP:8686/...(http://192.168.0.23:8686/...)  IP做域名访问，如果是内网IP，
         相同局域网下的用户可以访问这个服务，如果是外网IP，所有能联网的基本上都
	     可以访问这个服务（局域网下访问，需要互相关掉防火墙）
 */
~~~

#### 2.创建服务器的方式

![image-20210403160609054](4.node.assets/image-20210403160609054.png)

![image-20210403160715007](4.node.assets/image-20210403160715007.png)

#### 3.请求对象request

~~~JS
let http=require('http')
let url = require('url')
//=>创建WEB服务
let port = 8686;
let handle = function handle(req, res) {
    //=>REQ:REQUEST 请求对象，包含了客户端请求的信息
    // req.url 存储的是请求资源的路径地址及问号传参  例如：/stu/index.html?name=xxx&age=12
    // req.method 客户端请求的方式  例如：GET
    // req.headers 客户端的请求头信息，它是一个对象
    // ...
    //=>把请求的URL地址中：路径名称 & 问号传参 分别解析出来
    // let {pathname, query} = url.parse(req.url, true);
    // console.log(pathname, query);

    //=>RES:RESPONSE 响应对象，包含了一些属性和方法，可以让服务器端返回给客户端内容
    // res.write 基于这个方法，服务器端可以向客户端返回内容
    // res.end 结束响应
    // res.writeHead 重写响应头信息 
    // ...
    res.writeHead(200, {
        'content-type': 'text/plain;charset=utf-8;' //设置响应信息的格式
    });
    res.end(JSON.stringify({name: '哈哈哈'}));//=>服务器端返回给客户端的内容一般都是 STRING或者BUFFER格式的数据
};
http.createServer(handle).listen(port, () => {
    console.log(`server is success，listen on ${port}！`);
});
~~~

![image-20210403163130207](4.node.assets/image-20210403163130207.png)

#### 4.URL的解析

![image-20210403163226534](4.node.assets/image-20210403163226534.png)

![image-20210403163807961](4.node.assets/image-20210403163807961.png)

#### 5.method的处理

![image-20210403164343546](4.node.assets/image-20210403164343546.png)

![image-20210403164834115](4.node.assets/image-20210403164834115.png)

#### 6.headers

![image-20210403170158323](4.node.assets/image-20210403170158323.png)

![image-20210403170214970](4.node.assets/image-20210403170214970.png)

#### 7.响应对象response

![image-20210403171717369](4.node.assets/image-20210403171717369.png)

![image-20210403171652767](4.node.assets/image-20210403171652767.png)

![image-20210403172323975](4.node.assets/image-20210403172323975.png)

#### 8.http请求

![image-20210403173813744](4.node.assets/image-20210403173813744.png)

#### 9.文件上传

![image-20210403175138477](4.node.assets/image-20210403175138477.png)

![image-20210403175200915](4.node.assets/image-20210403175200915.png)

提升：

![image-20210403180138286](4.node.assets/image-20210403180138286.png)

![image-20210403182755234](4.node.assets/image-20210403182755234.png)

![image-20210403182812608](4.node.assets/image-20210403182812608.png)

### 5.events模块

![image-20210329020017948](4.node.assets/image-20210329020017948.png)

![image-20210329212519872](4.node.assets/image-20210329212519872.png)

![image-20210329015907085](4.node.assets/image-20210329015907085.png)

![image-20210329020500110](4.node.assets/image-20210329020500110.png)

![image-20210329021203641](4.node.assets/image-20210329021203641.png)

## 7.buffer的使用.

![image-20210330235510218](4.node.assets/image-20210330235510218.png)

### 1.buffer和二进制的关系

![image-20210330235815118](4.node.assets/image-20210330235815118.png)

![image-20210331001228283](4.node.assets/image-20210331001228283.png)

![image-20210331001305976](4.node.assets/image-20210331001305976.png)

### 2.buffer的其他方法

![image-20210331002025438](4.node.assets/image-20210331002025438.png)

![image-20210331003239770](4.node.assets/image-20210331003239770.png)

### 3.buffer的创建过程及原理

![image-20210331004201523](4.node.assets/image-20210331004201523.png)

![image-20210331004255421](4.node.assets/image-20210331004255421.png)

![image-20210331004340189](4.node.assets/image-20210331004340189.png)

![image-20210331004409941](4.node.assets/image-20210331004409941.png)

## 8.事件循环

### 1.事件循环的本质

![image-20210331005129734](4.node.assets/image-20210331005129734.png)

### 2.线程和进程的关系

![image-20210331005621347](4.node.assets/image-20210331005621347.png)

![image-20210331005659160](4.node.assets/image-20210331005659160.png)

### 3.javascript是单线程的

![image-20210331232650398](4.node.assets/image-20210331232650398.png)

![image-20210331233735389](4.node.assets/image-20210331233735389.png)

### 4.浏览器的事件循环

![image-20210331234242819](4.node.assets/image-20210331234242819.png)

![image-20210331234159309](4.node.assets/image-20210331234159309.png)

### 5.宏任务和微任务

![image-20210331235823602](4.node.assets/image-20210331235823602.png)

面试题：

![image-20210331235528244](4.node.assets/image-20210331235528244.png)

![image-20210401000556486](4.node.assets/image-20210401000556486.png)

### 6.node的事件循环

![image-20210401213500189](4.node.assets/image-20210401213500189.png)

![image-20210401214040336](4.node.assets/image-20210401214040336.png)

![image-20210401215212725](4.node.assets/image-20210401215212725.png)

![image-20210401215621259](4.node.assets/image-20210401215621259.png)

![image-20210401221236072](4.node.assets/image-20210401221236072.png)

![image-20210401221402724](4.node.assets/image-20210401221402724.png)

![image-20210401222705399](4.node.assets/image-20210401222705399.png)

面试题1：

![image-20210401223344219](4.node.assets/image-20210401223344219.png)

![image-20210401223143948](4.node.assets/image-20210401223143948.png)

面试题2：

![image-20210401223407662](4.node.assets/image-20210401223407662.png)

![image-20210401224613322](4.node.assets/image-20210401224613322.png)

![image-20210401224633894](4.node.assets/image-20210401224633894.png)

## 9.Stream（流）

![image-20210401225845883](4.node.assets/image-20210401225845883.png)

![image-20210401232107749](4.node.assets/image-20210401232107749.png)

![image-20210401232151380](4.node.assets/image-20210401232151380.png)

![image-20210401232226340](4.node.assets/image-20210401232226340.png)

![image-20210401232257880](4.node.assets/image-20210401232257880.png)

![image-20210401232319337](4.node.assets/image-20210401232319337.png)

![image-20210401232428668](4.node.assets/image-20210401232428668.png)

![image-20210401232519548](4.node.assets/image-20210401232519548.png)

## 10.express框架

![image-20210403183515635](4.node.assets/image-20210403183515635.png)

### 1.express安装

![image-20210403184513305](4.node.assets/image-20210403184513305.png)

![image-20210403184540833](4.node.assets/image-20210403184540833.png)

### 2.express的中间件

![image-20210405183957251](4.node.assets/image-20210405183957251.png)

![image-20210405184336575](4.node.assets/image-20210405184336575.png)

### 3.中间件的应用

![image-20210405185317002](4.node.assets/image-20210405185317002.png)

普通中间件：

![image-20210405185242971](4.node.assets/image-20210405185242971.png)

path中间件：

![image-20210405185913275](4.node.assets/image-20210405185913275.png)

path和method匹配中间件：

![image-20210405190506862](4.node.assets/image-20210405190506862.png)

连续注册多个中间件：

![image-20210405190859726](4.node.assets/image-20210405190859726.png)

### 4.body解析

![image-20210405192511691](4.node.assets/image-20210405192511691.png)

![image-20210405192446614](4.node.assets/image-20210405192446614.png)

### 5.body-parse的使用

![image-20210405192954335](4.node.assets/image-20210405192954335.png)

![image-20210405192836460](4.node.assets/image-20210405192836460.png)

### 6.from-data的解析

![image-20210406170409618](4.node.assets/image-20210406170409618.png)

![image-20210406171352529](4.node.assets/image-20210406171352529.png)

### 7.multer处理文件上传

![image-20210406173705714](4.node.assets/image-20210406173705714.png)

### 8.用Morgan保存express的日志信息

![image-20210406174628675](4.node.assets/image-20210406174628675.png)

### 9.客户端发送请求的方式

![image-20210406175317611](4.node.assets/image-20210406175317611.png)

![image-20210406175354344](4.node.assets/image-20210406175354344.png)

### 10.服务端响应数据

![image-20210406180829440](4.node.assets/image-20210406180829440.png)

### 11.express的路由（重点）

![image-20210406181530658](4.node.assets/image-20210406181530658.png)

### 12.静态资源服务器

![image-20210406182551623](4.node.assets/image-20210406182551623.png)

### 13.服务端的错误处理

![image-20210406183851972](4.node.assets/image-20210406183851972.png)

### 14.express源码解析

![image-20210406184346673](4.node.assets/image-20210406184346673.png)

![image-20210406185727262](4.node.assets/image-20210406185727262.png)

![image-20210406185754181](4.node.assets/image-20210406185754181.png)

![image-20210406185815265](4.node.assets/image-20210406185815265.png)

![image-20210406185830983](4.node.assets/image-20210406185830983.png)

## 11.koa框架

![image-20210414142900030](4.node.assets/image-20210414142900030.png)

### 1.koa基本使用

![image-20210414144554234](4.node.assets/image-20210414144554234.png)

### 2.koa注册中间件的方式

![image-20210414145858640](4.node.assets/image-20210414145858640.png)

~~~JS
const Koa=require('koa')
const app=new Koa()
app.use((ctx,next)=>{
  if (ctx.request.path==='/login') {
    if (ctx.request.method==='GET') {
      ctx.response.body="yes"
    }
  } else {
   ctx.response.body="nonononono"
})
app.listen(3000,()=>{
  console.log('koa start succse');
})
~~~

### 3.koa中路由的使用



![image-20210414152301910](4.node.assets/image-20210414152301910.png)

![image-20210414152448542](4.node.assets/image-20210414152448542.png)

### 4.参数解析 params / query

![image-20210414154102416](4.node.assets/image-20210414154102416.png)

![image-20210414154705845](4.node.assets/image-20210414154705845.png)

![image-20210414154436603](4.node.assets/image-20210414154436603.png)

### 5.参数解析：json/x-www-form-urlencoded

![image-20210414160423210](4.node.assets/image-20210414160423210.png)

![image-20210414160405825](4.node.assets/image-20210414160405825.png)

![image-20210414160607432](4.node.assets/image-20210414160607432.png)

### 6.参数解析：form-data

![image-20210414162154625](4.node.assets/image-20210414162154625.png)

![image-20210414162140211](4.node.assets/image-20210414162140211.png)

### 7.Multer上传文件

![image-20210414164831057](4.node.assets/image-20210414164831057.png)

![image-20210414164733836](4.node.assets/image-20210414164733836.png)

### 8.koa里面数据的响应

![image-20210414170011123](4.node.assets/image-20210414170011123.png)

### 9.静态服务器

![image-20210414170208924](4.node.assets/image-20210414170208924.png)

### 10.错误处理

![image-20210414170800622](4.node.assets/image-20210414170800622.png)

### 11.koa源码分析

![image-20210414172026274](4.node.assets/image-20210414172026274.png)



![image-20210414172044749](4.node.assets/image-20210414172044749.png)

![image-20210414172056234](4.node.assets/image-20210414172056234.png)

![image-20210414172110488](4.node.assets/image-20210414172110488.png)

![image-20210414172129036](4.node.assets/image-20210414172129036.png)

### 12.koa和express的区别

![image-20210414173825867](4.node.assets/image-20210414173825867.png)

![image-20210414173843656](4.node.assets/image-20210414173843656.png)

### 13.koa洋葱模型

![image-20210414224535595](4.node.assets/image-20210414224535595.png)

## 12.MySQL

![image-20210414230341633](4.node.assets/image-20210414230341633.png)

![image-20210414230442003](4.node.assets/image-20210414230442003.png)

![image-20210414230527434](4.node.assets/image-20210414230527434.png)

![image-20210414230553742](4.node.assets/image-20210414230553742.png)

### 1.安装

https://dev.mysql.com/downloads/mysql/

![image-20210415102533931](4.node.assets/image-20210415102533931.png)

![image-20210415102752619](4.node.assets/image-20210415102752619.png)

![image-20210415102952508](4.node.assets/image-20210415102952508.png)

![image-20210415103106953](4.node.assets/image-20210415103106953.png)

![image-20210415103240280](4.node.assets/image-20210415103240280.png)

![image-20210415103326616](4.node.assets/image-20210415103326616.png)

2.MySQL连接

![image-20210415103945446](4.node.assets/image-20210415103945446.png)

![image-20210415103849892](4.node.assets/image-20210415103849892.png)

![image-20210415104158783](4.node.assets/image-20210415104158783.png)

![image-20210415104215515](4.node.assets/image-20210415104215515.png)

![image-20210415104600419](4.node.assets/image-20210415104600419.png)

### 2.SQL语句

![image-20210415111917443](4.node.assets/image-20210415111917443.png)

![image-20210415112031268](4.node.assets/image-20210415112031268.png)

### 3.数据库的操作（DDL）

![image-20210415113726711](4.node.assets/image-20210415113726711.png)

![image-20210415113738312](4.node.assets/image-20210415113738312.png)

### 4.数据表的操作（DML）

![image-20210415143646922](4.node.assets/image-20210415143646922.png)

### 5.SQL的数据类型

#### 1.数字类型

![image-20210415145253412](4.node.assets/image-20210415145253412.png)

#### 2.日期类型

![image-20210415150644884](4.node.assets/image-20210415150644884.png)

#### 3.字符串类型

![image-20210415150914358](4.node.assets/image-20210415150914358.png)

### 6.表约束

![image-20210415151936788](4.node.assets/image-20210415151936788.png)

![image-20210415152129482](4.node.assets/image-20210415152129482.png)

### 7.创建一个完整的表

#### 1.创建

![image-20210415152904123](4.node.assets/image-20210415152904123.png)

​	**根据一张表的结构去创建另外一张表**

![image-20210415154013421](4.node.assets/image-20210415154013421.png)

#### 2.修改

![image-20210415153409907](4.node.assets/image-20210415153409907.png)

#### 3.插入数据（DML）

![image-20210415155130243](4.node.assets/image-20210415155130243.png)

![image-20210415155347204](4.node.assets/image-20210415155347204.png)

#### 4.删除和更新

![image-20210415160114388](4.node.assets/image-20210415160114388.png)

### 8.数据的查询一  单表操作（DQL）

![image-20210415161444209](4.node.assets/image-20210415161444209.png)

![image-20210415162021909](4.node.assets/image-20210415162021909.png)

#### 1.基本查询

![image-20210415162455496](4.node.assets/image-20210415162455496.png)

#### 2.where查询条件

![image-20210415163206706](4.node.assets/image-20210415163206706.png)

![image-20210415163725186](4.node.assets/image-20210415163725186.png)

![image-20210415164151131](4.node.assets/image-20210415164151131.png)

![image-20210415164851378](4.node.assets/image-20210415164851378.png)

#### 3.查询结果排序

![image-20210415165244695](4.node.assets/image-20210415165244695.png)

#### 4.分页查询

![image-20210415165728591](4.node.assets/image-20210415165728591.png)

#### 5.聚合函数

![image-20210416100142120](4.node.assets/image-20210416100142120.png)

#### 6.分组查询

![image-20210416101405473](4.node.assets/image-20210416101405473.png)

![image-20210416101837724](4.node.assets/image-20210416101837724.png)

### 9.数据的查询二  多表操作

![image-20210416103626615](4.node.assets/image-20210416103626615.png)

![image-20210416103643407](4.node.assets/image-20210416103643407.png)

#### 1.创建外键

![image-20210416104939795](4.node.assets/image-20210416104939795.png)

#### 2.外键存在时更新和删除数据

![image-20210416105044616](4.node.assets/image-20210416105044616.png)

![image-20210416110358358](4.node.assets/image-20210416110358358.png)

![image-20210416110405905](4.node.assets/image-20210416110405905.png)

![image-20210416110615585](4.node.assets/image-20210416110615585.png)

#### 3.什么是多表查询

![image-20210416111804418](4.node.assets/image-20210416111804418.png)

![image-20210416111858582](4.node.assets/image-20210416111858582.png)

#### 4.多表之间的连接 SQL JOIN

![image-20210416112607031](4.node.assets/image-20210416112607031.png)

#### 5.左连接

![image-20210416113151766](4.node.assets/image-20210416113151766.png)

#### 6.右连接

![image-20210416113433264](4.node.assets/image-20210416113433264.png)

#### 7.内连接

![image-20210416113925437](4.node.assets/image-20210416113925437.png)

#### 8.全连接

![image-20210416114441012](4.node.assets/image-20210416114441012.png)

### 10.数据的查询三  多表操作  多对多

![image-20210416115728751](4.node.assets/image-20210416115728751.png)

![image-20210416122338783](4.node.assets/image-20210416122338783.png)

#### 1.查询多对多数据

![image-20210416125013666](4.node.assets/image-20210416125013666.png)

![image-20210416125133613](4.node.assets/image-20210416125133613.png)

![image-20210416125253554](4.node.assets/image-20210416125253554.png)

### 11.将数据转成对象

![image-20210416130811664](4.node.assets/image-20210416130811664.png)

![image-20210416130754448](4.node.assets/image-20210416130754448.png)

![image-20210416130919310](4.node.assets/image-20210416130919310.png)

![image-20210416131719251](4.node.assets/image-20210416131719251.png)

### 12.node中操作MySQL

![image-20210416132852335](4.node.assets/image-20210416132852335.png)

#### 1.MySQL2基本使用

![image-20210416133035160](4.node.assets/image-20210416133035160.png)

#### 2.预编译语句

![image-20210416134055512](4.node.assets/image-20210416134055512.png)

#### 3.连接池

![image-20210422104803884](4.node.assets/image-20210422104803884.png)

![image-20210422104838050](4.node.assets/image-20210422104838050.png)

#### 4.ORM的使用

![image-20210422110848017](4.node.assets/image-20210422110848017.png)

![image-20210422111232035](4.node.assets/image-20210422111232035.png)

#### 5.Sequelize

![image-20210422111918498](4.node.assets/image-20210422111918498.png)

![image-20210422121701937](4.node.assets/image-20210422121701937.png)

![image-20210422122140441](4.node.assets/image-20210422122140441.png)

**一对多关系映射**:

![image-20210422122651923](4.node.assets/image-20210422122651923.png)

![image-20210422122916215](4.node.assets/image-20210422122916215.png)

![image-20210422123211358](4.node.assets/image-20210422123211358.png)

**多对多关系映射**：

![image-20210422124452530](4.node.assets/image-20210422124452530.png)

![image-20210422124913267](4.node.assets/image-20210422124913267.png)



















## node周啸天版

### 6.创建静态资源服务器

~~~JS
  服务器上有一堆项目代码，这堆项目代码中既可能有服务器端的程序代码，也有可能有客户端的程序代码，
  而客户端程序代码我们一般都放到static这个文件夹中

  ```
    static
      都是服务器端需要返回给客户端，由客户端浏览器渲染和解析的（前端项目：包括页面、CSS、JS、图片等）

    server.js
      都是需要在服务器端基于NODE执行的（后端项目：一般只有JS）
  ```
  我们创建的WEB服务需要处理两类请求：
     1.静态资源文件的请求处理：想要文件 要注意返回的文件对应的内容的格式
     2.API接口的请求处理：想要数据

     区别：第一类请求的地址中有后缀名，第二类没有后缀
~~~

**基础应用**：

~~~JS
let http=require('http')
let url = require('url')
let {readFile} =require('./utils/fsUtils')

let port=8090
let handel=function (req,res){
 //=>客户端请求资源文件(PATH-NAME)，服务器端都是到STATIC文件夹中进行读取，
 //也是根据客户端请求的路径名称读取的，服务器端基于FS读取文件中内容的时候，直接加上“./static”即可
 let {method,headers:reqheader}=req
 let {pathname,query}=url.parse(req.url,true) //pathname=/qianye.html
 readFile(`./static${pathname}`).then((result) => {
    //读取成功，返回对应的内容
    res.writeHead(200)
    res.end(result)
  }).catch((err) => {
    //读取失败，返回错误信息，大多数情况下是文件找不到,也就是客户端输入的地址栏有误
    res.writeHead(404,{'content-type':'text/plain;charset=utf-8'})
    res.end('not found file')
  });
}
~~~

![image-20210125143837162](4.node.assets/image-20210125143837162.png)

**解决图片不能显示的问题**：原因是在读取文件的时候，对所有的内容格式设置了“utf-8”，而图片、视频、音频这类文件是不需要设置的

![image-20210125145219348](4.node.assets/image-20210125145219348.png)

**浏览器兼容性处理**：

~~~js
let http=require('http')
let url = require('url')
let {readFile} =require('./utils/fsUtils')
let mime=require('mime') //获取文件对应的扩展名

let port=8090
let handel=function (req,res){
 //=>客户端请求资源文件(PATH-NAME)，服务器端都是到STATIC文件夹中进行读取，
 //也是根据客户端请求的路径名称读取的，服务器端基于FS读取文件中内容的时候，直接加上“./static”即可
 let {method,headers:reqheader}=req
 let {pathname,query}=url.parse(req.url,true) //pathname=/qianye.html
 let pathREG=/\.([a-z0-9]+)$/i

 //客户端请求静态资源文件时的处理，也就是请求的方式是带文件后缀名的
 if(pathREG.test(pathname)){
  readFile(`./static${pathname}`).then((result) => {
    //=>读取成功：根据请求资源文件的类型，设置响应内容的MIME 不同的文件对应的内容类型
    // console.log(result);
    let suffix=pathREG.exec(pathname)[1]  //获取文件的扩展名
    res.writeHead(200,{  //ie 下必须设置返回的内容格式
      'content-type': `${mime.getType(suffix)};charset=utf-8;`
    })
    res.end(result)
  }).catch((err) => {
    //读取失败，返回错误信息，大多数情况下是文件找不到,也就是客户端输入的地址栏有误
    res.writeHead(404,{'content-type':'text/plain;charset=utf-8'})
    res.end('not found file')
  });
     return
 }    
}
http.createServer(handel).listen(port,()=>{
  console.log(`server is successful,lisen on ${port}`);
})
~~~



### 7.创建动态资源服务（API请求）

静态资源处理主要是返回对应的文件资源，图片，音视频等。。。动态资源处理，就是API接口的处理，返回对应的数据，如数据库里面的用户信息。。。

#### 1.API接口的请求处理(get 获取指定用户信息)

**基本结构**：

![image-20210202114538380](4.node.assets/image-20210202114538380.png)

![image-20210202121924630](4.node.assets/image-20210202121924630.png)

![image-20210202121507994](4.node.assets/image-20210202121507994.png)

#### 2.API接口的请求处理(POST请求处理)

**服务端**：

~~~js
let http = require('http'),
    url = require('url'),
    path = require('path'),
    fs = require('fs');
let {readFile, writeFile} = require('./utils/fsPromise'),
    mime = require('mime'),
    qs = require('qs');

//=>公共方法
let responseResult = function responseResult(res, returnVal) {
    res.writeHead(200, {
        'content-type': 'application/json;charset=utf-8;'
    });
    res.end(JSON.stringify(returnVal));
};

let readUSER = function readUSER() {
    return readFile(`./json/USER.JSON`).then(result => {
        return JSON.parse(result);
    });
};

let readVOTE = function readVOTE() {
    return readFile(`./json/VOTE.JSON`).then(result => {
        return JSON.parse(result);
    });
};

//=>创建WEB服务
let port = 8686;
let handle = function handle(req, res) {
    //=>客户端请求资源文件(PATH-NAME)，服务器端都是到STATIC文件夹中进行读取，
	//也是根据客户端请求的路径名称读取的，服务器端基于FS读取文件中内容的时候，直接加上“./static”即可
    let {method, headers: requestHeaders} = req,
        {pathname, query} = url.parse(req.url, true),
        pathREG = /\.([a-z0-9]+)$/i;

    //=>静态资源文件处理
    if (pathREG.test(pathname)) {
        readFile(`./static${pathname}`).then(result => {
            //=>读取成功：根据请求资源文件的类型，设置响应内容的MIME
            let suffix = pathREG.exec(pathname)[1];
            res.writeHead(200, {
                'content-type': `${mime.getType(suffix)};charset=utf-8;`
            });
            res.end(result);
        }).catch(error => {
            //=>读取失败:最可能由于文件不存在而读取失败(也就是客户端请求的地址是错误的 ,我们应该响应的内容是404)
            res.writeHead(404, {'content-type': 'text/plain;charset=utf-8;'});
            res.end('NOT FOUND!');
        });
        return;
    }

    //=>API接口请求处理 动态资源处理

    //=>GET-USER:根据传递的用户ID获取指定用户的信息
    if (pathname === '/getUser' && method === 'GET') {
        //=>问号传递的信息都在QUERY中存储着
        let {userId = 0} = query,
            returnVal = {code: 1, message: 'no!', data: null};//设置默认返回信息
        readUSER().then(result => {
            let data = result.find(item => parseFloat(item['id']) === parseFloat(userId));
            if (data) {
                returnVal = {code: 0, message: 'ok', data:data};
                responseResult(res, returnVal);
                return;
            }
            throw new Error('');//=>目的是没有数据的时候,让其执行CATCH中的操作,这样我们只需要让THEN方法
			                    //中有异常信息即可,就会执行catch里面的操作
        }).catch(error => responseResult(res, returnVal));

        /*readUSER().then(result => {
            let data = result.find(item => parseFloat(item['id']) === parseFloat(userId));
            data ? returnVal = {code: 0, message: 'ok', data} : null;
        }).finally(result => {  //promise里面提供的方法除了then catch 还有final 不管成功还是失败都会执行这个方法
            //=>暂时NODE版本不支持FINALLY
            responseResult(res, returnVal);
        });*/
        return;
    }

    //=>REGIDTER:注册用户
    if (pathname === '/register' && method === 'POST') {
        //=>接收客户端请求主体传递的内容
        let pass = ``;
        req.on('data', chunk => {
            //=>正在接收请求主体内容,可能会被触发执行很多次,chunk获取的都是本次接收的BUFFER格式的数据
            pass += chunk;
        });
        req.on('end', () => {
            //=>已经把请求主体内容接收完成了  PASS是一个URLENCODED格式字符串，我们需要把它解析为对象
            pass = qs.parse(pass);
            readUSER().then(result => {
                //=>FORMAT-PASS
                let maxId = result.length <= 0 ? 0 : parseFloat(result[result.length - 1]['id']);
                pass.password = pass.password.substr(4, 24).split('').reverse().join('');
                let newData = {
                    id: maxId + 1,
                    name: '',
                    picture: `img/${pass.sex != 0 ? `woman` : `man`}.png`,
                    phone: '',
                    sex: 0,
                    password: '',
                    bio: '',
                    time: new Date().getTime(),
                    isMatch: 0,
                    matchId: '000',
                    slogan: '',
                    voteNum: 0,
                    ...pass
                };

                //=>把NEW-DATA追加到RESULT末尾,把最新的结果重新写入到文件
                result.push(newData);
                return writeFile('./json/USER.JSON', result);
            }).then(result => {
                responseResult(res, {
                    code: 0,
                    message: 'ok'
                });
            }).catch(error => {
                responseResult(res, {
                    code: 1,
                    message: 'no'
                });
            });
        });
        return;
    }
    //=>请求的都不是以上API接口,直接404即可
    res.writeHead(404);
    res.end('');
};
http.createServer(handle).listen(port, () => {
    console.log(`server is success，listen on ${port}！`);
});
~~~

**客户端**：

~~~js
<script src="js/axios.min.js"></script>
<script src="js/md5.min.js"></script>
<script>
    axios.defaults.baseURL = 'http://localhost:8686';
    axios.interceptors.response.use(result => result.data);//=>增加响应拦截器,在所有AXIOS请求成功后,把获取的结果中DATA单独返回(DATA就是服务器返回的JSON数据)
    axios.defaults.transformRequest = data => {
        //=>基于这个请求拦截器可以把POST和PUT等传递给服务器的请求主体内容进行格式化处理，DATA就是配置的请求主体对象
        let str = ``;
        if (data && typeof data === 'object') {
            for (let key in data) {
                if (data.hasOwnProperty(key)) {
                    str += `${key}=${data[key]}&`;
                }
            }
            data = str.substring(0, str.length - 1);
        }
        return data;
    };

    axios.get('/getUser', {
        params: {
            //=>GET请求问号传参：设置到PARAMS中即可
            userId: 1
        }
    }).then(result => {
        console.log(result);
    });

    // axios.post('/register', {
    //     //=>请求主体中需要传递给服务器的内容
    // }, {
    //     //=>CONFIG配置信息:例如可以设置请求头等信息
    // })

    //=>AXIOS默认基于请求主体传递给服务器的是RAW格式的:'{"name":"xxx"...}'，真实项目中我们和服务器约定的传输格式应该是X-WWW-URL-ENCODEED:"name=xxx&..."
    axios.post('/register', {
        //=>请求主体中需要传递给服务器的内容
        name: '测试',
        password: hex_md5('000000'),//=>密码需要经过MD5加密(不可逆转的加密)
        phone: '11111111111',
        sex: 0,
        bio: 'xxxxxxxxx'
    }).then(result => {
        console.log(result);
    });
</script>
~~~

### 8.JS中的同步异步（宏任务和微任务）

#### 1. JS中的同步异步编程

~~~JS
```
浏览器是多线程的，JS是单线程的（浏览器只分配一个线程来执行JS）
进程大线程小：一个进程中包含多个线程，例如在浏览器中打开一个HTML页面就占用了一个进程，
      加载页面的时候，浏览器分配一个线程去计算DOM树，分配其它的线程去加载对应的资源文件...
      再分配一个线程去自上而下执行JS

同步：在一个线程上（主栈/主任务队列）同一个时间只能做一件事情，当前事情完成才能进行下一个
        事情（先把一个任务进栈执行，执行完成，在把下一个任务进栈，上一个任务出栈...）

异步：在主栈中执行一个任务，但是发现这个任务是一个异步的操作，我们会把它移除主栈，
        放到等待任务队列中（此时浏览器会分配其它线程监听异步任务是否到达指定的执行时间）,
	如果主栈执行完成，监听者会把到达时间的异步任务重新放到主栈中执行...
    [宏任务：macro task]
        - 定时器
        - 事件绑定
        - ajax
        - 回调函数
        - Node中fs可以进行异步的I/O操作

    [微任务：micro task]
        - Promise(async/await)  =>promise本身是同步的 管理异步的操作 Promise并不是完全的同步，
	  当在Excutor（回调函数）中执行resolve或者reject的时候，此时是异步操作，会先执行then/catch等，当主栈完成后，
	  才会再去调用resolve/reject把存放的方法执行
        - process.nextTick

    执行顺序优先级：SYNC => MICRO => MACRO

  所有JS中的异步编程仅仅是根据某些机制来管控任务的执行顺序，不存在同时执行两个任务这一说法
 ```
~~~

![image-20210202153605543](4.node.assets/image-20210202153605543.png)

![image-20210202154730136](4.node.assets/image-20210202154730136.png)

~~~~js
//=>AJAX任务开始：SEND
//=>AJAX任务结束：状态为4

/*
let xhr = new XMLHttpRequest();
xhr.open('GET', 'xxx.txt', false);
/!*放到等待区的时候，此时状态是1*!/
xhr.onreadystatechange = () => {
    console.log(xhr.readyState);//=>4
};
xhr.send();
/!*状态为4的时候主栈空闲*!/*/

// let xhr = new XMLHttpRequest();
// xhr.open('GET', 'xxx.txt', false);
// xhr.send();
// /*状态已经为4了*/
// xhr.onreadystatechange = () => {
	//=>状态改变才会触发,放到等待区的时候状态已经为4了，不会在改变了，所以不会执行这个方法（啥都不会输出）
//     console.log(xhr.readyState);
// };

 let xhr = new XMLHttpRequest();
 xhr.open('GET', 'xxx.txt');
 xhr.send();//=>异步操作：执行SEND后，有一个线程是去请求数据，主栈会空闲下来
 /*放等待区之前状态是1*/
 xhr.onreadystatechange = () => {
     console.log(xhr.readyState);//=> 2 3 4
 };
 /*主栈又空闲了*/
 //状态为2  把函数执行
 //状态为3  把函数执行
 //状态为4  把函数执行
~~~~

#### 2.Promise里面的同步异步

~~~js
//1.基础的promise 有异步操作
console.log(1);
new Promise((resolve, reject) => {
    //=>new Promise的时候会立即把Excutor函数（也就是传递的回调函数）执行，所以Promise本身可以理解为是同步的
    console.log(2);
    setTimeout(() => {
        resolve();//=>Promise内部机制：执行resolve会把之前基于then存放的方法执行
    }, 10);
}).then(() => {
  //=>执行完成Excutor，紧接着执行then，执行then方法，会把传递的回调函数放到指定的容器中，等待触发执行（Promise内部的机制）
    console.log(3);
});
console.log(4);   //1 2 4 3

//2.基础的promise 没有异步操作
console.log(1);
new Promise((resolve, reject) => {
    console.log(2);
    resolve();
}).then(() => {
    console.log(3);
});
console.log(4);  // 1 2 4 3 
//如果按照promise是完全同步的话，先执行完resolve后再执行.then 此时应该输出的是 1 2 4 而是实际上 .then里面的方法也被执行了，
//所以promise内部本身有异步管控   resolve（）是一个异步操作 会先执行then/catch等，当主栈完成后，才会再去调用resolve存放的方法
~~~

#### 3.Promise里面的(async/await)

~~~JS
//=>ES7中新增加对Promise操作的新语法：async/await（使用await必须保证当前方法是基于async修饰的）
function AA() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            Math.random() < 0.5 ? reject(100) : resolve(200);
        }, 0);
    });
}
async function fn() {
    let res = await AA();
    //=>先把AA执行，等待AA中的PROMISE完成(不论成功和失败)，把最后的处理结果获取到赋值给RES，拿到后在执行后面的代码（有人说：AWAIT把是异步的操作同步化？）
}

//验证 AWAIT把是异步的操作同步化
function AA() {
    console.log(1);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(200);
        }, 0);
    });
}
async function fn() {
    console.log(2);
    let res = await AA();
    /*
     * 1.先把AA执行,返回一个PROMISE实例
     * 2.它会暂时跳出当前正在执行的函数(FN)：也就是AWAIT后面的代码暂时先不执行（把后面的代码从主栈中移除，放到等待区域中）
     * 3.主栈暂时空闲
     * 4.当主栈中的其它任务完成（主栈空闲），并且AA中的PROMISE也已经计算完成最后的结果，在把之前第二步移到等待区域的内容，
         重新拿回到主栈中执行
     */
    console.log(3);
}
fn();
console.log(4); //=> 2 1 4 3  =>AWAIT并不是同步 如果是同步应该输出 2 1 3 4
~~~

**提升**：

~~~JS
async function async1(){
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2(){
    console.log('async2');
}
console.log('script start');
setTimeout(function(){
     console.log('setTimeout');
 },0);
async1();
new Promise(function(resolve){
    console.log('promise1');
    resolve();
}).then(function(){
    console.log('promise2');
});
console.log('script end');
//=> 'script start'   'async1 start'  'async2'  'promise1'  'script end' ('promise2'或者'async1 end' 顺序根据不同的V8版本，是不一样的) 'setTimeout'
~~~

## 项目

### 1.QIANYE HUB项目

#### 1.功能说明及项目搭建

![image-20210422130754890](4.node.assets/image-20210422130754890.png)

![image-20210422131450421](4.node.assets/image-20210422131450421.png)

**快速启动**：

![image-20210422131804096](4.node.assets/image-20210422131804096.png)

![image-20210422132356941](4.node.assets/image-20210422132356941.png)

#### 2.配置环境变量











































